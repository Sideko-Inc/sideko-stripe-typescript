import {
  BalanceTransaction,
  External$BalanceTransaction,
  Schemas$BalanceTransaction,
} from "./balance-transaction";
import { Charge, External$Charge, Schemas$Charge } from "./charge";
import {
  External$PaymentFlowsPaymentIntentPresentmentDetails,
  PaymentFlowsPaymentIntentPresentmentDetails,
  Schemas$PaymentFlowsPaymentIntentPresentmentDetails,
} from "./payment-flows-payment-intent-presentment-details";
import {
  External$PaymentIntent,
  PaymentIntent,
  Schemas$PaymentIntent,
} from "./payment-intent";
import {
  External$RefundDestinationDetails,
  RefundDestinationDetails,
  Schemas$RefundDestinationDetails,
} from "./refund-destination-details";
import {
  External$RefundMetadata,
  RefundMetadata,
  Schemas$RefundMetadata,
} from "./refund-metadata";
import {
  External$RefundNextAction,
  RefundNextAction,
  Schemas$RefundNextAction,
} from "./refund-next-action";
import {
  External$TransferReversal,
  Schemas$TransferReversal,
  TransferReversal,
} from "./transfer-reversal";
import { zodTransform } from "@sideko-inc/stripe/core";
import * as z from "zod";

/**
 * Refund objects allow you to refund a previously created charge that isn't
 * refunded yet. Funds are refunded to the credit or debit card that's
 * initially charged.
 *
 * Related guide: [Refunds](https://stripe.com/docs/refunds)
 */
export type Refund = {
  /**
   * Amount, in cents (or local equivalent).
   */
  amount: number;
  /**
   * Balance transaction that describes the impact on your account balance.
   */
  balanceTransaction?: (string | BalanceTransaction) | undefined;
  /**
   * ID of the charge that's refunded.
   */
  charge?: (string | Charge) | undefined;
  /**
   * Time at which the object was created. Measured in seconds since the Unix epoch.
   */
  created: number;
  /**
   * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
   */
  currency: string;
  /**
   * An arbitrary string attached to the object. You can use this for displaying to users (available on non-card refunds only).
   */
  description?: string | undefined;
  destinationDetails?: RefundDestinationDetails | undefined;
  /**
   * After the refund fails, this balance transaction describes the adjustment made on your account balance that reverses the initial balance transaction.
   */
  failureBalanceTransaction?: (string | BalanceTransaction) | undefined;
  /**
   * Provides the reason for the refund failure. Possible values are: `lost_or_stolen_card`, `expired_or_canceled_card`, `charge_for_pending_refund_disputed`, `insufficient_funds`, `declined`, `merchant_request`, or `unknown`.
   */
  failureReason?: string | undefined;
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * For payment methods without native refund support (for example, Konbini, PromptPay), provide an email address for the customer to receive refund instructions.
   */
  instructionsEmail?: string | undefined;
  /**
   * Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
   */
  metadata?: RefundMetadata | null | undefined;
  nextAction?: RefundNextAction | undefined;
  /**
   * String representing the object's type. Objects of the same type share the same value.
   */
  object: "refund";
  /**
   * ID of the PaymentIntent that's refunded.
   */
  paymentIntent?: (string | PaymentIntent) | undefined;
  presentmentDetails?: PaymentFlowsPaymentIntentPresentmentDetails | undefined;
  /**
   * Reason for the refund, which is either user-provided (`duplicate`, `fraudulent`, or `requested_by_customer`) or generated by Stripe internally (`expired_uncaptured_charge`).
   */
  reason?:
    | (
        | "duplicate"
        | "expired_uncaptured_charge"
        | "fraudulent"
        | "requested_by_customer"
      )
    | null
    | undefined;
  /**
   * This is the transaction number that appears on email receipts sent for this refund.
   */
  receiptNumber?: string | null | undefined;
  /**
   * The transfer reversal that's associated with the refund. Only present if the charge came from another Stripe account.
   */
  sourceTransferReversal?: (string | TransferReversal) | undefined;
  /**
   * Status of the refund. This can be `pending`, `requires_action`, `succeeded`, `failed`, or `canceled`. Learn more about [failed refunds](https://stripe.com/docs/refunds#failed-refunds).
   */
  status?: string | null | undefined;
  /**
   * This refers to the transfer reversal object if the accompanying transfer reverses. This is only applicable if the charge was created using the destination parameter.
   */
  transferReversal?: (string | TransferReversal) | undefined;
};

/**
 * @internal
 * Refund without any key transformation, this is what
 * we expect to come in as network data
 */
export type External$Refund = {
  amount: number;
  balance_transaction?: (string | External$BalanceTransaction) | undefined;
  charge?: (string | External$Charge) | undefined;
  created: number;
  currency: string;
  description?: string | undefined;
  destination_details?: External$RefundDestinationDetails | undefined;
  failure_balance_transaction?:
    | (string | External$BalanceTransaction)
    | undefined;
  failure_reason?: string | undefined;
  id: string;
  instructions_email?: string | undefined;
  metadata?: External$RefundMetadata | null | undefined;
  next_action?: External$RefundNextAction | undefined;
  object: "refund";
  payment_intent?: (string | External$PaymentIntent) | undefined;
  presentment_details?:
    | External$PaymentFlowsPaymentIntentPresentmentDetails
    | undefined;
  reason?:
    | (
        | "duplicate"
        | "expired_uncaptured_charge"
        | "fraudulent"
        | "requested_by_customer"
      )
    | null
    | undefined;
  receipt_number?: string | null | undefined;
  source_transfer_reversal?: (string | External$TransferReversal) | undefined;
  status?: string | null | undefined;
  transfer_reversal?: (string | External$TransferReversal) | undefined;
};

/**
 * Takes network data, validates it, and transforms keys to match typescript object Refund
 */
const SchemaIn$Refund: z.ZodType<
  Refund, // output type of this zod object
  z.ZodTypeDef,
  unknown
> = z
  .object({
    amount: z.number().int(),
    balance_transaction: z
      .union([z.string(), z.lazy(() => Schemas$BalanceTransaction.in)])
      .optional(),
    charge: z.union([z.string(), z.lazy(() => Schemas$Charge.in)]).optional(),
    created: z.number().int(),
    currency: z.string(),
    description: z.string().optional(),
    destination_details: Schemas$RefundDestinationDetails.in.optional(),
    failure_balance_transaction: z
      .union([z.string(), z.lazy(() => Schemas$BalanceTransaction.in)])
      .optional(),
    failure_reason: z.string().optional(),
    id: z.string(),
    instructions_email: z.string().optional(),
    metadata: Schemas$RefundMetadata.in.nullable().optional(),
    next_action: Schemas$RefundNextAction.in.optional(),
    object: z.enum(["refund"]),
    payment_intent: z
      .union([z.string(), z.lazy(() => Schemas$PaymentIntent.in)])
      .optional(),
    presentment_details:
      Schemas$PaymentFlowsPaymentIntentPresentmentDetails.in.optional(),
    reason: z
      .enum([
        "duplicate",
        "expired_uncaptured_charge",
        "fraudulent",
        "requested_by_customer",
      ])
      .nullable()
      .optional(),
    receipt_number: z.string().nullable().optional(),
    source_transfer_reversal: z
      .union([z.string(), z.lazy(() => Schemas$TransferReversal.in)])
      .optional(),
    status: z.string().nullable().optional(),
    transfer_reversal: z
      .union([z.string(), z.lazy(() => Schemas$TransferReversal.in)])
      .optional(),
  })
  .transform((obj) => {
    return zodTransform(obj, {
      amount: "amount",
      balance_transaction: "balanceTransaction",
      charge: "charge",
      created: "created",
      currency: "currency",
      description: "description",
      destination_details: "destinationDetails",
      failure_balance_transaction: "failureBalanceTransaction",
      failure_reason: "failureReason",
      id: "id",
      instructions_email: "instructionsEmail",
      metadata: "metadata",
      next_action: "nextAction",
      object: "object",
      payment_intent: "paymentIntent",
      presentment_details: "presentmentDetails",
      reason: "reason",
      receipt_number: "receiptNumber",
      source_transfer_reversal: "sourceTransferReversal",
      status: "status",
      transfer_reversal: "transferReversal",
    });
  });

/**
 * @internal
 * Takes typescript data, validates it, and maps keys to match the expected external object External$Refund
 */
const SchemaOut$Refund: z.ZodType<
  External$Refund, // output type of this zod object
  z.ZodTypeDef,
  Refund // the object to be transformed
> = z
  .object({
    amount: z.number().int(),
    balanceTransaction: z
      .union([z.string(), z.lazy(() => Schemas$BalanceTransaction.out)])
      .optional(),
    charge: z.union([z.string(), z.lazy(() => Schemas$Charge.out)]).optional(),
    created: z.number().int(),
    currency: z.string(),
    description: z.string().optional(),
    destinationDetails: Schemas$RefundDestinationDetails.out.optional(),
    failureBalanceTransaction: z
      .union([z.string(), z.lazy(() => Schemas$BalanceTransaction.out)])
      .optional(),
    failureReason: z.string().optional(),
    id: z.string(),
    instructionsEmail: z.string().optional(),
    metadata: Schemas$RefundMetadata.out.nullable().optional(),
    nextAction: Schemas$RefundNextAction.out.optional(),
    object: z.enum(["refund"]),
    paymentIntent: z
      .union([z.string(), z.lazy(() => Schemas$PaymentIntent.out)])
      .optional(),
    presentmentDetails:
      Schemas$PaymentFlowsPaymentIntentPresentmentDetails.out.optional(),
    reason: z
      .enum([
        "duplicate",
        "expired_uncaptured_charge",
        "fraudulent",
        "requested_by_customer",
      ])
      .nullable()
      .optional(),
    receiptNumber: z.string().nullable().optional(),
    sourceTransferReversal: z
      .union([z.string(), z.lazy(() => Schemas$TransferReversal.out)])
      .optional(),
    status: z.string().nullable().optional(),
    transferReversal: z
      .union([z.string(), z.lazy(() => Schemas$TransferReversal.out)])
      .optional(),
  })
  .transform((obj) => {
    return zodTransform(obj, {
      amount: "amount",
      balanceTransaction: "balance_transaction",
      charge: "charge",
      created: "created",
      currency: "currency",
      description: "description",
      destinationDetails: "destination_details",
      failureBalanceTransaction: "failure_balance_transaction",
      failureReason: "failure_reason",
      id: "id",
      instructionsEmail: "instructions_email",
      metadata: "metadata",
      nextAction: "next_action",
      object: "object",
      paymentIntent: "payment_intent",
      presentmentDetails: "presentment_details",
      reason: "reason",
      receiptNumber: "receipt_number",
      sourceTransferReversal: "source_transfer_reversal",
      status: "status",
      transferReversal: "transfer_reversal",
    });
  });

export const Schemas$Refund = {
  in: SchemaIn$Refund,
  out: SchemaOut$Refund,
};
